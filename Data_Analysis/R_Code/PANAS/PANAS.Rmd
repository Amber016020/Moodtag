---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 
```{r}
# install.packages("lme4")
# install.packages("Depends")
# install.packages("psych")
```

```{r}
library(ggplot2)
library(dplyr)
library(readr)
library(tidyverse)
library(ggplot2)
library(car)
library(psych)
library(tidyr)
library(broom)
```

```{r}
setwd("./data/")
# 讀取 data CSV 文件
data <- read_csv("survey_finish.csv", locale = locale(encoding = "UTF-8"))

data <- data %>%
  mutate(mode = ifelse(mode == "self-affect", "manual affect", mode))
# 刪掉表現不好的受測者
data <- data %>%
  filter(!str_detect(user_id, "^6526") 
         #& !str_detect(user_id, "^6610")
         & !str_detect(user_id, "^2555")
         #& !str_detect(user_id, "^241")
         & !str_detect(user_id, "^5497")
         #& !str_detect(user_id, "^6172")
         #& !str_detect(user_id, "^8944")
         #& !str_detect(user_id, "^4486")
         #& !str_detect(user_id, "^4030")
         #& !str_detect(user_id, "^2953")
         #& !str_detect(user_id, "^6646")
         #& !str_detect(user_id, "^342")
         #& !str_detect(user_id, "^1398")
         #& !str_detect(user_id, "^9890")
         #& !str_detect(user_id, "^8468")
         #& !str_detect(user_id, "^817")
         )

# Step 1: 轉為長格式並計算每個子量表的總得分
panas_data <- data %>%
  filter(scaleName == "PANAS") %>%
  mutate(across(c(neutral, pre, post), as.numeric)) %>%
  pivot_longer(cols = c(neutral, pre, post), names_to = "time", values_to = "score") %>%
  mutate(subscale = case_when(
    question_number %in% c(1, 3, 5, 9, 10, 12, 14, 16, 17, 19) ~ "Positive",
    question_number %in% c(2, 4, 6, 7, 8, 11, 13, 15, 18, 20) ~ "Negative"
  )) %>%
  group_by(user_id, userName, mode, time, subscale) %>%
  summarize(total_score = sum(score, na.rm = TRUE), .groups = "drop")

# Step 2: 轉為寬格式
panas_data_wide <- panas_data %>%
  pivot_wider(names_from = c(time, subscale), values_from = total_score)

print(panas_data_wide)

# 定義每個子量表的問題號碼
n_dif_questions <- c(2, 8, 14, 20)
p_dif_questions <- c(5, 11, 17, 23)
n_ddf_questions <- c(1, 7, 13, 19)
p_ddf_questions <- c(4, 10, 16, 22)
g_eot_questions <- c(3, 6, 9, 12, 15, 18, 21, 24)

# 將問題號碼對應到子量表並計算每位受測者在每個子量表中的得分
paq_data <- data %>%
  filter(scaleName == "PAQ") %>%
  mutate(neutral = as.numeric(neutral)) %>%
  mutate(subscale = case_when(
    question_number %in% n_dif_questions ~ "N-DIF",
    question_number %in% p_dif_questions ~ "P-DIF",
    question_number %in% n_ddf_questions ~ "N-DDF",
    question_number %in% p_ddf_questions ~ "P-DDF",
    question_number %in% g_eot_questions ~ "G-EOT",
    TRUE ~ NA_character_  # 處理不在範圍內的值
  )) %>%
  group_by(user_id, userName, mode, subscale) %>%
  summarize(total_score = sum(post, na.rm = TRUE), .groups = 'drop')  # 計算每位受測者的總分

# 1. 計算每位受測者在PAQ的總分

paq_total_data <- data %>%
  filter(scaleName == "PAQ" & mode == "control") %>%
  mutate(neutral = as.numeric(neutral)) %>%
  mutate(subscale = case_when(
    question_number %in% n_dif_questions ~ "N_DIF",
    question_number %in% p_dif_questions ~ "P_DIF",
    question_number %in% n_ddf_questions ~ "N_DDF",
    question_number %in% p_ddf_questions ~ "P_DDF",
    question_number %in% g_eot_questions ~ "G_EOT",
    TRUE ~ NA_character_
  )) %>%
  group_by(user_id, userName, subscale) %>%
  summarize(
    subscale_score = sum(neutral, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  # 將 subscale 列轉換為 wide 格式
  pivot_wider(
    names_from = subscale,
    values_from = subscale_score,
    values_fill = 0  # 缺失值填充為 0
  ) %>%
  # 添加一列表示所有子量表總分
  mutate(
    Total_Score = rowSums(select(., starts_with("N_"), starts_with("P_"), starts_with("G_")))
  )

print(paq_total_data)

# TPA 數據轉換為長格式並計算信任/不信任總分
tpa_data <- data %>%
  filter(scaleName == "TPA") %>%
  mutate(post = as.numeric(post)) %>%
  pivot_longer(cols = post, names_to = "time", values_to = "score") %>%
  mutate(subscale = case_when(
    question_number %in% distrust_questions ~ "Distrust",
    question_number %in% trust_questions ~ "Trust",
    TRUE ~ NA_character_  # 處理不在範圍內的值
  )) %>%
  group_by(user_id,userName, subscale, time) %>%
  summarise(total_score = sum(score, na.rm = TRUE), .groups = 'drop')

abcct_data <- data %>%
  filter(scaleName == "ABCCT") %>%
  pivot_longer(cols = c(neutral, post), names_to = "communication_tool", values_to = "score") %>%
  mutate(mode = ifelse(communication_tool == "neutral", "common", "Moodtag")) %>%
  mutate(subscale = case_when(
    question_number %in% c(1, 2, 3) ~ "Emotion_Express",
    question_number %in% c(4, 5, 6) ~ "Engagement_Play",
    question_number %in% c(7, 8, 9) ~ "Presence_in_Absence",
    question_number %in% c(10, 11, 12, 13, 14) ~ "Social_Support",
    question_number %in% c(15, 16, 17, 18) ~ "Obligations",
    question_number %in% c(19, 20, 21, 22) ~ "Unmet_Expectations",
    question_number %in% c(23, 24, 25, 26) ~ "Threat_to_Privacy"
  )) %>%
  group_by(user_id, userName, mode, subscale) %>%
  summarize(total_score = sum(score, na.rm = TRUE), .groups = "drop")

abcct_data <- abcct_data %>%
  filter(mode == "common") %>%
  pivot_wider(names_from = c(subscale), values_from = total_score)%>%
  rename(tool = mode)

print(panas_data)
print(paq_data)
print(tpa_data)
print(abcct_data)
```
```{r}
# 定義一個函數來處理情緒項目
process_panas_items <- function(data, scale_name) {
  data %>%
    filter(scaleName == scale_name) %>%
    mutate(across(c(neutral, pre, post), as.numeric)) %>%
    pivot_longer(cols = c(neutral, pre, post), names_to = "time", values_to = "score") %>%
    mutate(
      emotion = case_when(
        # 負面情緒項目
        question_number == 2 ~ "心煩意亂",
        question_number == 4 ~ "心緒不寧",
        question_number == 6 ~ "內疚懊悔",
        question_number == 7 ~ "恐懼",
        question_number == 8 ~ "充滿敵意",
        question_number == 11 ~ "生氣暴躁",
        question_number == 13 ~ "扭捏、難為情",
        question_number == 15 ~ "緊張不安",
        question_number == 18 ~ "忐忑不安",
        question_number == 20 ~ "惶恐懼怕",
        # 正面情緒項目
        question_number == 1 ~ "感興趣的",
        question_number == 3 ~ "充滿活力",
        question_number == 5 ~ "幹勁十足",
        question_number == 9 ~ "備受鼓舞",
        question_number == 10 ~ "感到自豪",
        question_number == 12 ~ "意志堅定",
        question_number == 14 ~ "專心致志",
        question_number == 16 ~ "精力充沛",
        question_number == 17 ~ "敏銳謹慎",
        question_number == 19 ~ "充滿激情",
        TRUE ~ NA_character_
      )
    ) %>%
    filter(!is.na(emotion)) # 過濾出有效的情緒項目
}

# 1. 處理 PANAS 資料
panas_item_data <- process_panas_items(data, "PANAS")

panas_item_data <- panas_item_data %>%
  left_join(panas_data_wide, by = c("user_id", "userName", "mode"))

panas_item_data <- panas_item_data %>%
  left_join(paq_total_data, by = c("user_id", "userName"))

panas_item_data <- panas_item_data %>%
  left_join(abcct_data, by = c("user_id", "userName"))

# 移除 tpa_data 中的 time 欄位
tpa_data_alter <- tpa_data %>%
  select(-time)

# 將 distrust 和 trust 從直的轉換成橫的
tpa_data_alter <- tpa_data_alter %>%
  pivot_wider(names_from = subscale, values_from = total_score)

panas_item_data <- panas_item_data %>%
  left_join(tpa_data_alter, by = c("user_id", "userName"))


# 2. 計算每個用戶在 post 和 pre 之間的分數差異
panas_diff <- panas_item_data %>%
  filter(time %in% c('pre', 'post')) %>%
  pivot_wider(names_from = time, values_from = score) %>%
  mutate(difference = post - pre) %>%
  select(user_id, mode, emotion, difference ,neutral_Negative,neutral_Positive,G_EOT,N_DDF,N_DIF,P_DDF,P_DIF,Total_Score,Emotion_Express,Engagement_Play,Presence_in_Absence,Social_Support,Obligations,Unmet_Expectations,Threat_to_Privacy , Distrust , Trust)

# 計算每種情緒對 mode 的 one way ANOVA 及事後檢定
analyze_emotion_anova <- function(data) {
  # 儲存 ANOVA 結果和事後檢定結果的列表
  anova_results <- list()
  post_hoc_results <- list()
  
  # 獲取所有情緒
  emotions <- unique(data$emotion)
  
  # 對每種情緒進行 ANOVA
  #for (emotion in emotions) {
  for (emotion in c("感興趣的","敏銳謹慎", "內疚懊悔","生氣暴躁")) {
    # 過濾出當前情緒的數據
    emotion_data <- data %>%
      filter(emotion == !!emotion)
    
    emotion_data <- emotion_data[emotion_data$Total_Score >= 40, ]

        # 如果數據足夠，進行 ANOVA
    if (nrow(emotion_data) > 1) {
      anova_result <- aov(difference ~ mode + N_DDF+P_DDF +Distrust+neutral_Negative  + Emotion_Express + Engagement_Play + Presence_in_Absence + Social_Support + Obligations + Unmet_Expectations + Threat_to_Privacy, data = emotion_data)

      #anova_result <- aov(difference ~ mode + neutral_Negative + Total_Score +N_DDF+P_DDF  + Emotion_Express +Engagement_Play+Presence_in_Absence+Social_Support+Obligations+Unmet_Expectations+Threat_to_Privacy+ Distrust + Trust, data = emotion_data)

      #anova_result <- aov(difference ~ mode + neutral_Negative + Total_Score +G_EOT+N_DDF+N_DIF+P_DDF+P_DIF + Distrust + Trust, data = emotion_data)
      
      #anova_result <- aov(difference ~ mode, data = emotion_data)
      
      summary_result <- summary(anova_result)
      
      # 儲存 ANOVA 結果
      anova_results[[emotion]] <- summary_result
      
      # 進行 Tukey's HSD 事後檢定
      post_hoc_result <- TukeyHSD(anova_result)
      
      # 儲存事後檢定結果
      post_hoc_results[[emotion]] <- post_hoc_result
    }
  }
  
  return(list(anova_results = anova_results, post_hoc_results = post_hoc_results))
}

# 使用函數進行 ANOVA 分析和事後檢定
results <- analyze_emotion_anova(panas_diff)

# 查看 ANOVA 結果
anova_results <- results$anova_results
print(anova_results)

# 查看事後檢定結果
post_hoc_results <- results$post_hoc_results
print(post_hoc_results)


panas_diff <- panas_diff %>%  filter(emotion %in% c("敏銳謹慎"))

print(panas_diff)
```

```{r}
print(panas_diff)
# 計算每個 mode 和 emotion 下的平均差異、標準差和標準誤差
panas_diff_avg <- panas_diff %>%
  group_by(mode, emotion) %>%
  summarize(
    mean_difference = mean(difference, na.rm = TRUE),  # 計算每組的平均差異
    sd_difference = sd(difference, na.rm = TRUE),      # 計算標準差
    n = n()                                            # 計算每組的樣本數
  ) %>%
  ungroup() %>%
  mutate(se = sd_difference / sqrt(n))  # 計算標準誤差

# 使用 ggplot2 畫出長條圖並加上誤差條
p <- ggplot(panas_diff_avg, aes(x = emotion, y = mean_difference, fill = mode)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), width = 0.5) +
  geom_errorbar(aes(ymin = mean_difference - se, ymax = mean_difference + se), 
                position = position_dodge(width = 0.9), width = 0.2) +  # 添加誤差條
  labs(x = "Emotion", y = "Mean Change in PANAS Score", title = "Mean Changes in PANAS Scores by Condition") +
  theme_minimal() +
  scale_fill_manual(values = c("Moodtag" = "#c44e52", "control" = "#4c72b0", "manual affect" = "#55a868")) +
  theme_minimal() +
  theme(legend.position = "none")
p

# 保存圖形，增加高度
ggsave("emotion_barplot.png", p, height = 6, width = 8)  # 調整圖片高度和寬度
```


```{r}
# 定義一個函數來處理情緒項目
process_panas_items <- function(data, scale_name) {
  data %>%
    filter(scaleName == scale_name) %>%
    mutate(across(c(neutral, pre, post), as.numeric)) %>%
    pivot_longer(cols = c(neutral, pre, post), names_to = "time", values_to = "score") %>%
    mutate(
      emotion = case_when(
        # 負面情緒項目
        question_number == 2 ~ "心煩意亂",
        question_number == 4 ~ "心緒不寧",
        question_number == 6 ~ "內疚懊悔",
        question_number == 7 ~ "恐懼",
        question_number == 8 ~ "充滿敵意",
        question_number == 11 ~ "生氣暴躁",
        question_number == 13 ~ "扭捏、難為情",
        question_number == 15 ~ "緊張不安",
        question_number == 18 ~ "忐忑不安",
        question_number == 20 ~ "惶恐懼怕",
        # 正面情緒項目
        question_number == 1 ~ "感興趣的",
        question_number == 3 ~ "充滿活力",
        question_number == 5 ~ "幹勁十足",
        question_number == 9 ~ "備受鼓舞",
        question_number == 10 ~ "感到自豪",
        question_number == 12 ~ "意志堅定",
        question_number == 14 ~ "專心致志",
        question_number == 16 ~ "精力充沛",
        question_number == 17 ~ "敏銳謹慎",
        question_number == 19 ~ "充滿激情",
        TRUE ~ NA_character_
      )
    ) %>%
    filter(!is.na(emotion)) # 過濾出有效的情緒項目
}

# 1. 處理 PANAS 資料
panas_item_data <- process_panas_items(data, "PANAS")

panas_item_data <- panas_item_data %>%
  left_join(panas_data_wide, by = c("user_id", "userName", "mode"))

panas_item_data <- panas_item_data %>%
  left_join(paq_total_data, by = c("user_id", "userName"))

# 移除 tpa_data 中的 time 欄位
tpa_data_alter <- tpa_data %>%
  select(-time)

# 將 distrust 和 trust 從直的轉換成橫的
tpa_data_alter <- tpa_data_alter %>%
  pivot_wider(names_from = subscale, values_from = total_score)

panas_item_data <- panas_item_data %>%
  left_join(tpa_data_alter, by = c("user_id", "userName"))


print(panas_item_data)

# 2. 計算每個用戶在 post 和 pre 之間的分數差異
panas_diff <- panas_item_data %>%
  filter(time %in% c('pre', 'post')) %>%
  pivot_wider(names_from = time, values_from = score) %>%
  mutate(difference = post - pre) %>%
  select(user_id, mode, emotion, difference ,neutral_Negative, Total_Score , Distrust , Trust)


# 計算每種情緒對 mode 的 one way ANOVA 及事後檢定
analyze_emotion_anova <- function(data) {
  # 儲存 ANOVA 結果和事後檢定結果的列表
  anova_results <- list()
  post_hoc_results <- list()
  
  # 獲取所有情緒
  emotions <- unique(data$emotion)
  
  # 對每種情緒進行 ANOVA
  for (emotion in emotions) {
  # for (emotion in c("感興趣的", "敏銳謹慎", "內疚懊悔","生氣暴躁")) {
    # 過濾出當前情緒的數據
    emotion_data <- data %>%
      filter(emotion == !!emotion)
    
    emotion_data <- emotion_data[emotion_data$Total_Score >= 40, ]

    # 如果數據足夠，進行 ANOVA
    if (nrow(emotion_data) > 1) {
      anova_result <- aov(difference ~ mode + neutral_Negative + Total_Score + Distrust + Trust, data = emotion_data)
      summary_result <- summary(anova_result)
      
      # 儲存 ANOVA 結果
      anova_results[[emotion]] <- summary_result
      
      # 進行 Tukey's HSD 事後檢定
      post_hoc_result <- TukeyHSD(anova_result)
      
      # 儲存事後檢定結果
      post_hoc_results[[emotion]] <- post_hoc_result
    }
  }
  
  return(list(anova_results = anova_results, post_hoc_results = post_hoc_results))
}

# 使用函數進行 ANOVA 分析和事後檢定
results <- analyze_emotion_anova(panas_diff)

# 查看 ANOVA 結果
anova_results <- results$anova_results
print(anova_results)

# 查看事後檢定結果
post_hoc_results <- results$post_hoc_results
print(post_hoc_results)


panas_diff %>%   filter(emotion %in% c("感興趣的", "敏銳謹慎", "內疚懊悔","生氣暴躁"))

# 加總相同 user_id、mode 和 emotion 的 difference
panas_diff_sum <- panas_diff %>%
  group_by(mode, emotion) %>%
  summarize(total_difference = sum(difference, na.rm = TRUE)) %>%
  ungroup()

# 使用 ggplot2 畫出長條圖
p <- ggplot(panas_diff_sum, aes(x = emotion, y = total_difference, fill = mode)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "Condition", y = "Mean change in PANAS Score", title = "Differences in PANAS in the High Alexithymia Group") +
  theme_minimal() +
  scale_fill_manual(values = c("Moodtag" = "blue", "control" = "red", "manual" = "green")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # 讓x軸標籤旋轉45度以便顯示

# 保存圖形，增加高度
ggsave("emotion_barplot.png", p, height = 6, width = 8)  # 調整圖片高度和寬度
```

```{r}
# 保存刪除前的資料
original_data <- panas_diff

# 篩選被刪除的 user_id
removed_users <- original_data$user_id[original_data$Total_Score < 40]

# 查看被刪除的 user_id
print(removed_users)
```


```{r}


# 先計算整體資料中的分位數
quantiles <- quantile(panas_item_data$paq_total_score, c(0.33, 0.66), na.rm = TRUE)

# 1. 根據 paq_total_score 分組
panas_item_data <- panas_item_data %>%
  mutate(
    paq_group = case_when(
      paq_total_score <= quantiles[1] ~ "Low",    # 低分組
      paq_total_score > quantiles[1] & paq_total_score <= quantiles[2] ~ "Medium", # 中分組
      paq_total_score > quantiles[2] ~ "High"     # 高分組
    )
  )

# 2. 計算每個用戶在 post 和 pre 之間的分數差異
panas_diff <- panas_item_data %>%
  filter(time %in% c('pre', 'post')) %>%
  pivot_wider(names_from = time, values_from = score) %>%
  mutate(difference = post - pre) %>%
  select(user_id, mode, emotion, difference, neutral_Negative, paq_total_score, paq_group)

# 3. 計算每種情緒對 paq_group 和 mode 的 one way ANOVA 及事後檢定
analyze_emotion_anova <- function(data) {
  # 儲存 ANOVA 結果和事後檢定結果的列表
  anova_results <- list()
  post_hoc_results <- list()
  
  # 獲取所有情緒
  emotions <- unique(data$emotion)
  
# 進行每個情緒對不同述情障礙組別的 ANOVA
for (emotion in emotions) {
  # 過濾出當前情緒的數據
  emotion_data <- data %>%
    filter(emotion == !!emotion)
  
  # 如果數據足夠，進行 ANOVA
  if (nrow(emotion_data) > 1) {
    # 儲存 ANOVA 結果
    emotion_anova_results <- list()
    
    # 進行述情障礙分組的 ANOVA（低、中、高）
    for (group in c("Low", "Medium", "High")) {
      # 過濾出當前述情障礙組別的數據
      group_data <- emotion_data %>%
        filter(paq_group == group)
      
      # 如果該組別數據足夠，進行 ANOVA
      if (nrow(group_data) > 1) {
        anova_result <- aov(difference ~ mode, data = group_data)
        summary_result <- summary(anova_result)
        
        # 儲存 ANOVA 結果
        emotion_anova_results[[group]] <- summary_result
        
        # 進行 Tukey's HSD 事後檢定
        post_hoc_result <- TukeyHSD(anova_result)
        
        # 儲存事後檢定結果
        emotion_anova_results[[paste0(group, "_post_hoc")]] <- post_hoc_result
      }
    }
    
    # 儲存每個情緒在不同述情障礙分組的 ANOVA 和事後檢定結果
    anova_results[[emotion]] <- emotion_anova_results
  }
}

# 查看每個情緒的 ANOVA 結果
print(anova_results)

# 查看每個情緒在不同述情障礙分組的事後檢定結果
for (emotion in emotions) {
  if (!is.null(anova_results[[emotion]])) {
    print(paste("Emotion:", emotion))
    print("ANOVA Results:")
    print(anova_results[[emotion]])
  }
}
  
  return(list(anova_results = anova_results, post_hoc_results = post_hoc_results))
}

# 使用函數進行 ANOVA 分析和事後檢定
results <- analyze_emotion_anova(panas_diff)

# 查看 ANOVA 結果
anova_results <- results$anova_results
print(anova_results)

# 查看事後檢定結果
post_hoc_results <- results$post_hoc_results
print(post_hoc_results)

```

```{r}
# 過濾出述情障礙高組別的數據
high_group_data <- panas_diff %>%
  filter(paq_group == "High")

# 計算每個 mode 的平均分數和標準差
summary_data <- high_group_data %>%
  group_by(mode) %>%
  summarise(
    mean_diff = mean(difference, na.rm = TRUE),
    sd_diff = sd(difference, na.rm = TRUE)
  )

print(summary_data)

# 繪製條形圖並顯示標準差
ggplot(summary_data, aes(x = mode, y = mean_diff, fill = mode)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +  # 長條圖
  geom_errorbar(aes(ymin = mean_diff - sd_diff, ymax = mean_diff + sd_diff), width = 0.2) +  # 誤差條
  labs(
    title = "Comparison of Condition in High PAQ Group",
    x = "Condition (Mode)",
    y = "Mean Difference (Post - Pre)"
  ) +
  theme_minimal() +
  scale_fill_brewer(palette = "Set3")

```


```{r}
# 1. 過濾出述情障礙高組別資料，並篩選出三個情緒
high_group_data <- panas_diff %>%
  filter(paq_group == "High" & emotion %in% c("心煩意亂", "充滿活力", "內疚懊悔"))

# 2. 計算每個情緒在 pre 和 post 狀況下的均值和標準差
emotion_summary <- high_group_data %>%
  group_by(emotion, mode) %>%
  summarise(
    mean_diff = mean(difference, na.rm = TRUE),  # 計算均值
    sd_diff = sd(difference, na.rm = TRUE),      # 計算標準差
    .groups = "drop"
  )

# 3. 使用 ggplot2 畫出長條圖
library(ggplot2)

plot <- ggplot(emotion_summary, aes(x = emotion, y = mean_diff, fill = mode)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(
    aes(ymin = mean_diff - sd_diff, ymax = mean_diff + sd_diff),
    position = position_dodge(width = 0.8),
    width = 0.25
  ) +
  labs(
    title = "Differences in PANAS in the High Alexithymia Group",
    x = "Condition",
    y = "PANAS diff （Post - Pre）",
    fill = "Condition"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )



# 儲存圖像為 PNG 檔案
ggsave("high_alexithymia_emotion_difference.png", plot = plot, width = 8, height = 6, dpi = 300, bg = "white")
```

```{r}

# 找誰該刪掉
plot_diff <- function(data, time1, time2, title) {
  
  # 計算各 mode 的分數差異
  diff_scores_test <- data %>%
    pivot_wider(names_from = time, values_from = total_score) %>%
    mutate(diff_score = !!sym(time2) - !!sym(time1)) %>%
    filter(!is.na(diff_score) & subscale == "Negative")  # 確保有分數變化
  
  print(diff_scores_test)
  
  # 將資料依 user_id 分組，並找出 control 低於 manual affect 與 moodtag 的資料
  filtered_diff_scores <- diff_scores_test %>%
    group_by(user_id) %>%
    filter(
      any(mode == "control" & diff_score < diff_score[mode == "manual"]) &
      any(mode == "control" & diff_score < diff_score[mode == "Moodtag"])
    ) %>%
    ungroup()
  
  print(filtered_diff_scores)
}

# 生成 post - pre 的圖表
plot_diff(panas_data, "pre", "post", "Average Difference in PANAS Scores (Post - Pre) Across Different Modes")

# 生成 post - neutral 的圖表
plot_diff(panas_data, "post", "neutral", "Average Difference in PANAS Scores (Post - Neutral) Across Different Modes")
```

```{r}

# 定義一個函數來計算差距和繪製圖表
plot_diff <- function(data, time1, time2, title) {
  
  diff_scores <- data %>%
    pivot_wider(names_from = time_panas, values_from = total_score_panas) %>%
    mutate(difference = !!sym(time2) - !!sym(time1)) %>%
    select(user_id, mode, subscale_panas, difference)

  average_diff <- diff_scores %>%
    group_by(mode, subscale_panas) %>%
    summarize(average_difference = mean(difference, na.rm = TRUE),
              sd = sd(difference)) %>%
    ungroup()
  
  
  # 繪製平均差異圖
  plot_avg <- ggplot(average_diff, aes(x = mode, y = average_difference, fill = subscale_panas)) +
      geom_bar(stat = "identity", position = "dodge", width = 0.6) +
      geom_errorbar(aes(ymin = average_difference - sd,
                        ymax = average_difference + sd), 
                    position = position_dodge(0.6), width = 0.25) +
      theme_minimal() +
      labs(title = title,
           x = "Condition",
           y = "PANAS Difference Scores",
           fill = "Subscale") +
      scale_fill_manual(values = c("turquoise", "lightcoral")) +
      theme(panel.background = element_rect(fill = "white"), 
            plot.background = element_rect(fill = "white"),
            legend.position = "top", 
            plot.title = element_text(hjust = 0.5))

  # 顯示平均差異圖
  print(plot_avg)
}


# 合併 PANAS 和 TPA 數據集
combined_PANAS_TPA_data <- panas_data %>%
  inner_join(tpa_data, by = c("user_id"), suffix = c("_panas", "_tpa"))

# 生成 post - pre 的圖表
plot_diff(combined_PANAS_TPA_data,"pre", "post", "Average Difference in PANAS Scores (Post - Pre) Across Different Modes")

# 生成 post - neutral 的圖表
plot_diff(combined_PANAS_TPA_data,"post", "neutral", "Average Difference in PANAS Scores (Post - Neutral) Across Different Modes")


# 定義一個函數來進行 ANOVA 分析
run_anova <- function(data, time1, time2, subscale_filter) {
  
  data <- data %>%
    pivot_wider(names_from = time_panas, values_from = total_score_panas) %>%
    mutate(difference = !!sym(time2) - !!sym(time1))
  
  # 1. 篩選指定的 subscale 和 time1, time2 的資料
  filtered_data <- data %>%
    filter(subscale_tpa == 'Distrust')

  # 4. 執行單因子 ANOVA，針對不同的 mode
  anova_result <- aov(difference ~ mode, data = filtered_data )

  # 5. 輸出 ANOVA 結果
  cat("\n--- ANOVA Results for", subscale_filter, "(", time1, "vs", time2, ") ---\n")
  print(summary(anova_result))
  
  # 6. 如果需要檢查事後分析，可以使用 TukeyHSD
  tukey_result <- TukeyHSD(anova_result)
  
  # 7. 輸出 Tukey 結果
  cat("\n--- Tukey HSD Results for", subscale_filter, "(", time1, "vs", time2, ") ---\n")
  print(tukey_result)
  
  # 返回 ANOVA 結果和事後分析結果
  list(anova = summary(anova_result), tukey = tukey_result)
}

# 對於 Positive 情感，分析 post - pre
run_anova(combined_PANAS_TPA_data,"pre", "post", "Positive")

# 對於 Negative 情感，分析 post - pre
run_anova(combined_PANAS_TPA_data,"pre", "post", "Negative")
```

```{r}

# 定義一個函數來計算差距和繪製圖表
plot_diff <- function(data, time1, time2, title) {
  
  diff_scores <- data %>%
    pivot_wider(names_from = time_panas, values_from = total_score_panas) %>%
    mutate(difference = !!sym(time2) - !!sym(time1)) %>%
    select(user_id, mode, subscale_panas, difference)

  # 使用 IQR 方法刪除離群值
  Q1 <- quantile(diff_scores$difference, 0.25, na.rm = TRUE)
  Q3 <- quantile(diff_scores$difference, 0.75, na.rm = TRUE)
  IQR_value <- Q3 - Q1
  
  # 進行篩選，保留在 Q1 - 1.5*IQR 到 Q3 + 1.5*IQR 範圍內的數據
  filtered_diff_scores <- diff_scores %>%
    filter(difference >= (Q1 - 1.5 * IQR_value) & difference <= (Q3 + 1.5 * IQR_value))
  
  average_diff <- filtered_diff_scores %>%
    group_by(mode, subscale_panas) %>%
    summarize(average_difference = mean(difference, na.rm = TRUE),
              n = n(),
              sd = sd(difference),
              ci = qt(0.975, df = n - 1) * (sd / sqrt(n))) %>% # 計算 95% 信賴區間
    ungroup()
  
  # 繪製平均差異圖
  plot_avg <- ggplot(average_diff, aes(x = mode, y = average_difference, fill = subscale_panas)) +
    geom_bar(stat = "identity", position = "dodge", width = 0.6) +
    geom_errorbar(aes(ymin = average_difference - ci, 
                      ymax = average_difference + ci), 
                  position = position_dodge(0.6), width = 0.25) + # 使用信賴區間
    theme_minimal() +
    labs(title = title,
         x = "Condition",
         y = "PANAS Difference Scores",
         fill = "Subscale") +
    scale_fill_manual(values = c("turquoise", "lightcoral")) +
    theme(panel.background = element_rect(fill = "white"), 
          plot.background = element_rect(fill = "white"),
          legend.position = "top", 
          plot.title = element_text(hjust = 0.5))


  # 顯示平均差異圖
  print(plot_avg)
}

# 生成 post - pre 的圖表
plot_diff(combined_PANAS_TPA_data, "pre", "post", "Average Difference in PANAS Scores (Post - Pre) Across Different Modes")

# 定義一個函數來進行 ANOVA 分析
run_anova <- function(data, time1, time2, subscale_filter, emotion_type) {
  
  data <- data %>%
    pivot_wider(names_from = time_panas, values_from = total_score_panas) %>%
    mutate(difference = !!sym(time2) - !!sym(time1))
  
  # 使用 IQR 方法刪除離群值
  Q1 <- quantile(data$difference, 0.25, na.rm = TRUE)
  Q3 <- quantile(data$difference, 0.75, na.rm = TRUE)
  IQR_value <- Q3 - Q1
  
  # 篩選出不包含離群值的數據
  filtered_data <- data %>%
    filter(difference >= (Q1 - 1.5 * IQR_value) & difference <= (Q3 + 1.5 * IQR_value)) %>%
    filter(subscale_tpa == subscale_filter & subscale_panas == emotion_type)

  # 檢查層次數
  if(length(unique(filtered_data$mode)) < 2) {
      cat("\n--- Not enough levels for ANOVA for", emotion_type, "(", time1, "vs", time2, ") ---\n")
      return(NULL)
  }
  
  print(filtered_data)

  # 執行單因子 ANOVA，針對不同的 mode，若您有不同的實驗組別（如不同的情感模式），可以使用 ANCOVA 將 TPA 作為共變數來進行調整，以檢查在不同情感模式下，是否 TPA 的變化會顯著影響 Moodtag 得分
  anova_result <- aov(difference ~ mode + total_score_tpa , data = filtered_data )

  # 輸出 ANOVA 結果
  cat("\n--- ANOVA Results for", subscale_filter, "(", time1, "vs", time2, ") ---\n")
  print(summary(anova_result))
  
  # 檢查事後分析
  tukey_result <- TukeyHSD(anova_result)
  
  # 輸出 Tukey 結果
  cat("\n--- Tukey HSD Results for", subscale_filter, "(", time1, "vs", time2, ") ---\n")
  print(tukey_result)
  
  # 返回 ANOVA 結果和事後分析結果
  list(anova = summary(anova_result), tukey = tukey_result)
}

# 對於 Positive 情感，分析 post - pre
run_anova(combined_PANAS_TPA_data, "pre", "post", "Trust", "Positive")

# 對於 Positive 情感，分析 post - pre
run_anova(combined_PANAS_TPA_data, "pre", "post", "Trust", "Negative")


# 對於 Negative 情感，分析 post - pre
run_anova(combined_PANAS_TPA_data, "pre", "post", "Distrust", "Positive")

# 對於 Negative 情感，分析 post - pre
run_anova(combined_PANAS_TPA_data, "pre", "post", "Distrust", "Negative")

```



```{r}
# 計算手動模式和控制模式的分數差異
diff_scores <- diff_panas_subscale_scores %>%
  filter(mode %in% c("manual affect", "control")) %>%
  select(user_id, mode, diff_score) %>%  # 確保選擇 user_id
  pivot_wider(names_from = mode, values_from = diff_score) %>%
  mutate(score_difference = `manual affect` - control)


# 計算分數差異的閾值
threshold <- quantile(diff_scores$score_difference, 0.25, na.rm = TRUE)  # 使用 25% 分位數作為閾值

# 確定需要刪除的用戶 ID
users_to_delete <- diff_scores %>%
  filter(score_difference < threshold) %>%
  pull(user_id)  # 假設 user_id 是用戶的唯一標識

print(users_to_delete)

# 過濾數據，刪除這些用戶的所有數據
filtered_data <- diff_panas_subscale_scores %>%
  filter(!user_id %in% users_to_delete)

# 檢查過濾後的數據
print(filtered_data)

# 進行 ANOVA 分析，使用 diff_score
anova_result <- aov(diff_score ~ mode, data = filtered_data)
summary(anova_result)

# 6. 如果需要檢查事後分析，可以使用 TukeyHSD
tukey_result <- TukeyHSD(anova_result)
print(tukey_result)

```


```{r}

# 定義一個函數來計算差距和繪製圖表
plot_diff <- function(data, time1, time2, title) {
  diff_scores <- data %>%
    pivot_wider(names_from = time, values_from = total_score) %>%
    mutate(difference = !!sym(time2) - !!sym(time1)) %>%
    select(user_id, mode, subscale, difference)
  
  # 將同一用戶的資料加總
  summed_scores <- diff_scores %>%
    group_by(user_id, mode, subscale) %>%
    summarize(total_difference = sum(difference, na.rm = TRUE), .groups = 'drop')

  # 計算IQR來篩選離群值
  IQR_value <- IQR(summed_scores$total_difference, na.rm = TRUE)
  lower_bound <- quantile(summed_scores$total_difference, 0.25, na.rm = TRUE) - 1.5 * IQR_value
  upper_bound <- quantile(summed_scores$total_difference, 0.75, na.rm = TRUE) + 1.5 * IQR_value
  
  # 過濾掉離群值
  filtered_scores <- summed_scores %>%
    filter(total_difference >= lower_bound & total_difference <= upper_bound)

  # 計算平均差異
  average_diff <- filtered_scores %>%
    group_by(mode, subscale) %>%
    summarize(average_difference = mean(total_difference, na.rm = TRUE),
              sd = sd(total_difference), .groups = 'drop') %>%
    ungroup()

  # 繪製平均差異圖
  plot_avg <- ggplot(average_diff, aes(x = mode, y = average_difference, fill = subscale)) +
      geom_bar(stat = "identity", position = "dodge", width = 0.6) +
      geom_errorbar(aes(ymin = average_difference - sd,
                        ymax = average_difference + sd), 
                    position = position_dodge(0.6), width = 0.25) +
      theme_minimal() +
      labs(title = title,
           x = "Condition",
           y = "PANAS Difference Scores",
           fill = "Subscale") +
      scale_fill_manual(values = c("turquoise", "lightcoral")) +
      theme(panel.background = element_rect(fill = "white"), 
            plot.background = element_rect(fill = "white"),
            legend.position = "top", 
            plot.title = element_text(hjust = 0.5))

  # 顯示平均差異圖
  print(plot_avg)
}

# 生成 post - pre 的圖表
plot_diff(subscale_scores, "pre", "post", "Average Difference in PANAS Scores (Post - Pre) Across Different Modes")

# 定義一個函數來進行 ANOVA 分析
run_anova <- function(data, time1, time2, subscale_filter) {
  # 1. 篩選指定的 subscale 和 time1, time2 的資料
  filtered_data <- data %>%
    filter(time %in% c(time1, time2), subscale == subscale_filter)
  
  # 2. 將資料轉換為寬格式，並確保同一個 user_id 和 mode
  diff_scores <- filtered_data %>%
    pivot_wider(names_from = time, values_from = total_score) %>%
    filter(!is.na(!!sym(time1)) & !is.na(!!sym(time2)))  # 移除缺失值，確保兩個時間點都有分數
  
  # 3. 計算差異分數 (time2 - time1)
  diff_scores <- diff_scores %>%
    mutate(difference = !!sym(time2) - !!sym(time1))
  
  print(diff_scores)
  
  # 4. 計算 IQR 並篩選離群值
  IQR_value <- IQR(diff_scores$difference, na.rm = TRUE)
  lower_bound <- quantile(diff_scores$difference, 0.25, na.rm = TRUE) - 1.5 * IQR_value
  upper_bound <- quantile(diff_scores$difference, 0.75, na.rm = TRUE) + 1.5 * IQR_value
  
  # 5. 過濾掉離群值
  filtered_diff_scores <- diff_scores %>%
    filter(difference >= lower_bound & difference <= upper_bound)
  
  # 除了 IQR 外，使用 2 標準差方法
  mean_diff <- mean(filtered_diff_scores$difference, na.rm = TRUE)
  sd_diff <- sd(filtered_diff_scores$difference, na.rm = TRUE)
  lower_bound_sd <- mean_diff - 2 * sd_diff
  upper_bound_sd <- mean_diff + 2 * sd_diff

  # 再次過濾
  filtered_diff_scores <- filtered_diff_scores %>%
    filter(difference >= lower_bound_sd & difference <= upper_bound_sd)
  
  # 除了 IQR 外，使用 2 標準差方法
  mean_diff <- mean(filtered_diff_scores$difference, na.rm = TRUE)
  sd_diff <- sd(filtered_diff_scores$difference, na.rm = TRUE)
  lower_bound_sd <- mean_diff - 2 * sd_diff
  upper_bound_sd <- mean_diff + 2 * sd_diff

  # 再次過濾
  filtered_diff_scores <- filtered_diff_scores %>%
    filter(difference >= lower_bound_sd & difference <= upper_bound_sd)

  # 6. 確保至少有兩個觀察值以進行 ANOVA
  if(nrow(filtered_diff_scores) < 2) {
    cat("\nNot enough data for ANOVA after filtering outliers.\n")
    return(NULL)
  }
  
  # 7. 執行單因子 ANOVA，針對不同的 mode
  anova_result <- aov(difference ~ mode, data = filtered_diff_scores)
  
  # 8. 輸出 ANOVA 結果
  cat("\n--- ANOVA Results for", subscale_filter, "(", time1, "vs", time2, ") ---\n")
  print(summary(anova_result))
  
  # 9. 如果需要檢查事後分析，可以使用 TukeyHSD
  tukey_result <- TukeyHSD(anova_result)
  
  # 10. 輸出 Tukey 結果
  cat("\n--- Tukey HSD Results for", subscale_filter, "(", time1, "vs", time2, ") ---\n")
  print(tukey_result)
  
  # 返回 ANOVA 結果和事後分析結果
  list(anova = summary(anova_result), tukey = tukey_result)
}

# 對於 Positive 情感，分析 post - pre
run_anova(subscale_scores, "pre", "post", "Positive")

# 對於 Negative 情感，分析 post - pre
run_anova(subscale_scores, "pre", "post", "Negative")
```




```{r}


# 定義一個函數來進行 RM ANOVA 分析
run_rm_anova <- function(data, time1, time2, subscale_filter) {
  # 1. 篩選指定的 subscale 和時間點
  filtered_data <- data %>%
    filter(time %in% c(time1, time2), subscale == subscale_filter)

  # 2. 將資料轉換為寬格式
  wide_data <- filtered_data %>%
    pivot_wider(names_from = time, values_from = total_score) %>%
    filter(!is.na(get(time1)) & !is.na(get(time2)))  # 確保兩個時間點都有分數

  # 3. 執行重複測量 ANOVA
  anova_result <- aov(cbind(get(time1), get(time2)) ~ mode + Error(user_id/(mode)), data = wide_data)

  # 4. 輸出 ANOVA 結果
  cat("\n--- RM ANOVA Results for", subscale_filter, " ---\n")
  print(summary(anova_result))

  # 5. 進行配對樣本 T 檢定
  t_test_result <- t.test(wide_data[[time1]], wide_data[[time2]], paired = TRUE)

  # 輸出 T 檢定結果
  cat("\n--- Paired Sample T-Test Results ---\n")
  print(t_test_result)

  # 返回 ANOVA 結果和事後檢定結果
  return(list(anova = summary(anova_result), t_test = t_test_result))
}

# 對於 Negative 情感，分析 pre - post
run_rm_anova(subscale_scores, "pre", "post", "Negative")
# 對於 Negative 情感，分析 neutral - post
run_rm_anova(subscale_scores, "neutral", "post", "Negative")

```

```{r}
# 1. 計算每位受測者在PAQ的總分
paq_total_data <- paq_data %>%
  filter(mode == "control" ) %>%
  group_by(user_id, userName) %>%
  summarize(paq_total_score = sum(neutral, na.rm = TRUE)) %>%
  ungroup()

# 計算均值和標準差
paq_mean <- mean(paq_total_data$paq_total_score, na.rm = TRUE)
paq_sd <- sd(paq_total_data$paq_total_score, na.rm = TRUE)

# 根據均值和標準差劃分群組
paq_total_data <- paq_total_data %>%
  mutate(group = case_when(
    paq_total_score > (paq_mean + paq_sd) ~ "High Alexithymia",
    paq_total_score < (paq_mean - paq_sd) ~ "Low Alexithymia",
    TRUE ~ "Moderate Alexithymia"
  ))

print(paq_total_data)

# 3. 將分組結果與差異數據合併
diff_scores <- subscale_scores %>%
  left_join(paq_total_data, by = "user_id")

# 4. 將數據轉換為寬格式，然後計算差異分數
diff_scores_wide <- diff_scores %>%
  pivot_wider(names_from = time, values_from = total_score) %>%
  filter(!is.na(pre) & !is.na(post)) %>%  # 移除缺失值
  mutate(difference = post - pre)

# 2. 計算每組的平均負面情緒下降
average_diff <- diff_scores_wide %>%
  group_by(group,mode,subscale) %>%
  summarize(average_negative_difference = mean(difference, na.rm = TRUE),
            sd = sd(difference)) %>%
  ungroup()

average_diff_neg <- average_diff %>%
  filter(subscale == "Negative")

# 3. 繪製圖表
plot_negative_emotion <- ggplot(average_diff_neg, aes(x = factor(group, levels = c("Low Alexithymia", "Moderate Alexithymia", "High Alexithymia")), 
                                                      y = average_negative_difference, 
                                                      fill = factor(group, levels = c("Low Alexithymia", "Moderate Alexithymia", "High Alexithymia")))) +
  geom_bar(stat = "identity", position = "dodge", width = 0.6) +
  geom_errorbar(aes(ymin = average_negative_difference - 1.96 * sd,
                    ymax = average_negative_difference + 1.96 * sd), 
                width = 0.25, position = position_dodge(0.6)) +
  facet_grid(~ mode) +  # 只根據 mode 分開
  theme_minimal() +
  labs(title = "PANAS Negative Emotion Change (Post - Pre) by Alexithymia Classification",
       x = "PAQ Group Classification",
       y = "Average Increase in Negative Emotion by Alexithymia Classification",
       fill = "Group") +
  scale_fill_manual(values = c("lightgreen", "lightblue" ,"lightcoral")) +
  theme(panel.background = element_rect(fill = "white"),
        plot.background = element_rect(fill = "white"),
        legend.position = "top",
        plot.title = element_text(hjust = 0.5))

# 顯示圖表
print(plot_negative_emotion)
# 保存图表到指定路径
ggsave(filename = "E:/Research/part/圖表/pilot/PANAS Negative Emotion Change (Post - Pre) by Alexithymia Classification.png", 
       plot = plot_negative_emotion, 
       width = 10, 
       height = 8, 
       dpi = 300)

negative_difference <- diff_scores_wide %>%
  filter(subscale == "Negative")

print(negative_difference)

# 2. 進行 Two-Way ANOVA
anova_result_negative <- aov(difference  ~ mode * group, data = negative_difference)

# 3. 輸出 ANOVA 結果
cat("\n--- Two-Way ANOVA Results for Negative Emotion ---\n")
print(summary(anova_result_negative))

# 4. 進行事後分析
tukey_result_negative <- TukeyHSD(anova_result_negative)

cat("\n--- Tukey HSD Results for Negative Emotion ---\n")
print(tukey_result_negative)


```

```{r}
# 1. 篩選正面情緒的資料
positive_scores <- subscale_scores %>%
  filter(subscale == "Positive" & !time == "neutral")

# 2. 確保 `time` 和 `mode` 是因子
positive_scores <- positive_scores %>%
  mutate(time = factor(time, levels = c("pre", "post")),
         mode = factor(mode))

# 3. 進行 Two-Way ANOVA
anova_result_positive <- aov(total_score ~ time * mode, data = positive_scores)

# 4. 輸出 ANOVA 結果
cat("\n--- Two-Way ANOVA Results for Positive Emotion Subscale ---\n")
summary(anova_result_positive)

# 5. 進行事後分析（Tukey HSD）
tukey_result_positive <- TukeyHSD(anova_result_positive)

cat("\n--- Tukey HSD Results for Positive Emotion Subscale ---\n")
print(tukey_result_positive)



# 1. 篩選負面情緒的資料
negative_scores <- subscale_scores %>%
  filter(subscale == "Negative" & !time == "neutral")

# 2. 確保 `time` 和 `mode` 是因子
negative_scores <- negative_scores %>%
  mutate(time = factor(time, levels = c("pre", "post")),
         mode = factor(mode))

# 3. 進行 Two-Way ANOVA
anova_result <- aov(total_score ~ time * mode, data = negative_scores)

# 4. 輸出 ANOVA 結果
cat("\n--- Two-Way ANOVA Results for Negative Emotion Subscale ---\n")
summary(anova_result)

# 5. 進行事後分析（Tukey HSD）
tukey_result <- TukeyHSD(anova_result)

cat("\n--- Tukey HSD Results for Negative Emotion Subscale ---\n")
print(tukey_result)
```






```{r}

# 計算每組的軍職、標準差和樣本量
summary_stats <- subscale_scores %>%
  group_by(mode, time, subscale) %>%
  summarise(
    mean_score = mean(total_score, na.rm = TRUE),
    sd = sd(total_score, na.rm = TRUE),
    n = n(),
    .groups = 'drop'
  ) %>%
  mutate(
    se = sd / sqrt(n),  
    ymin = mean_score - se,  
    ymax = mean_score + se   
  )

# 設定 time 的順序
summary_stats <- summary_stats %>%
  mutate(time = factor(time, levels = c("neutral", "pre", "post")))

# 分別畫出 neutral 到 post 和 pre 到 post
# neutral 到 post
summary_neutral_post <- summary_stats %>%
  filter(time %in% c("neutral", "post"))

ggplot(summary_neutral_post, aes(x = time, y = mean_score, color = mode, linetype = mode, group = interaction(mode, subscale))) +
  geom_line(size = 0.5, position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), width = 0.4, size = 0.5, position = position_dodge(width = 0.5)) +  
  geom_point(aes(shape = mode), size = 2, position = position_dodge(width = 0.5)) +
  theme_minimal() +
  facet_wrap(~ subscale, scales = "free_y") +
  labs(title = "PANAS Scores from Neutral to Post",
       x = "Time",
       y = "PANAS Scores",
       color = "Condition",
       linetype = "Condition",
       shape = "Condition") +
  scale_color_manual(values = c("#4c72b0", "#55a868", "#c44e52")) +  
  scale_linetype_manual(values = c("solid", "solid", "solid")) + 
  scale_shape_manual(values = c(16, 17, 18)) +
  theme(plot.title = element_text(hjust = 0.5))

# pre 到 post
summary_pre_post <- summary_stats %>%
  filter(time %in% c("pre", "post"))

ggplot(summary_pre_post, aes(x = time, y = mean_score, color = mode, linetype = mode, group = interaction(mode, subscale))) +
  geom_line(size = 0.5, position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), width = 0.4, size = 0.5, position = position_dodge(width = 0.5)) +  
  geom_point(aes(shape = mode), size = 2, position = position_dodge(width = 0.5)) +
  theme_minimal() +
  facet_wrap(~ subscale, scales = "free_y") +
  labs(title = "PANAS Scores from Pre to Post",
       x = "Time",
       y = "PANAS Scores",
       color = "Condition",
       linetype = "Condition",
       shape = "Condition") +
  scale_color_manual(values = c("#4c72b0", "#55a868", "#c44e52")) +  
  scale_linetype_manual(values = c("solid", "solid", "solid")) + 
  scale_shape_manual(values = c(16, 17, 18)) +
  theme(plot.title = element_text(hjust = 0.5))

```
```{r}
print(subscale_scores)
# 計算每組的軍職、標準差和樣本量
summary_stats <- subscale_scores %>%
  group_by(user_id, mode, time, subscale) %>%  # 加入 user_id
  summarise(
    mean_score = mean(total_score, na.rm = TRUE),
    sd = sd(total_score, na.rm = TRUE),
    n = n(),
    .groups = 'drop'
  ) %>%
  mutate(
    se = sd / sqrt(n),  
    ymin = mean_score - se,  
    ymax = mean_score + se   
  )

# 計算每個用戶的 post-pre 分數差異
post_pre_diff <- subscale_scores %>%
  filter(time %in% c("pre", "post")) %>%
  group_by(user_id, mode, subscale) %>%
  summarise(
    post_score = mean(total_score[time == "post"], na.rm = TRUE),
    pre_score = mean(total_score[time == "pre"], na.rm = TRUE),
    score_diff = post_score - pre_score,
    .groups = 'drop'
  )

# 將結果合併以便進行 ANOVA
anova_data <- post_pre_diff %>%
  select(user_id, mode, subscale, score_diff)

# 執行 ANOVA
anova_results <- aov(score_diff ~ mode + Error(user_id/mode), data = anova_data)
summary(anova_results)

# 如果需要，將結果顯示出來
print(summary(anova_results))
```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
